# =============================================================================
# Imports
# =============================================================================

# Dist-utils
from distutils.command.clean import clean as Clean

# Operating system
from   pkg_resources import parse_version
import os
import shutil
import traceback
import sys

# =============================================================================
# Include classes and methods that are needed for the package metadata
# =============================================================================

# =============================================================================
# Clean command
# =============================================================================

class CleanCommand(Clean):
    """
        Custom clean command to remove build artifacts.
    """

    def run(self):
        """
            Execute the custom clean command.
        """
        # Call to the method of the parent
        super().run()

        # Locate the current working directory
        cwd = os.path.abspath(os.path.dirname(__file__))

        # Remove the ".c" and ".cpp" files if the current working directory
        # is not a distribution
        remove_c_files = not os.path.exists(os.path.join(cwd, "PKG-INFO"))

        # Remove the "build" directory if it exists
        if os.path.exists("build"):
            shutil.rmtree("build")

        # Iterate all files and folders within the package
        for (dirpath, dirnames, filenames) in os.walk("plr"):
            # Iterate all the found files
            for filename in filenames:
                # Get the current extension of the file
                filename_ext = os.path.splitext(filename)[1]
                # If the extension is either ".c" or ".cpp", check
                # whether to remove it (taking into account that
                # it cannot be a distribution)
                if filename_ext in [".c", ".cpp"] and remove_c_files:
                    # Important: Only remove the ".c" and ".cpp" files
                    # that have been generated by Cython, that is,
                    # if they exists, in the same directory, a ".pyx"
                    # file with the same name
                    pyx_filename = str.replace(filename, filename_ext, ".pyx")
                    # If this ".pyx" file exists, then, remove the corresponding
                    # ".c" or ".cpp" one
                    if os.path.exists(os.path.join(dirpath, pyx_filename)):
                        os.unlink(os.path.join(dirpath, filename))
            # Iterate all the found folders
            for dirname in dirnames:
                # Remove the "__pycache__" folders
                if dirname == "__pycache__":
                    shutil.rmtree(os.path.join(dirpath, dirname))

# =============================================================================
# Public objects
# =============================================================================

# Package metadata
DISTNAME         = "plr"
DESCRIPTION      = "A set of Python modules for the Partial Label Ranking problem."
MAINTAINER       = "Juan Carlos Alfaro Jiménez"
MAINTAINER_EMAIL = "JuanCarlos.Alfaro@uclm.es"
URL              = "https://github.com/alfaro96/PLR"
DOWNLOAD_URL     = "https://github.com/alfaro96/PLR/archive/1.0.0.tar.gz"
LICENSE          = "MIT"
VERSION          = "1.0.0"

CLASSIFIERS      = ["Development Status :: 5 - Production/Stable",
                    "Intended Audience :: Science/Research",
                    "License :: OSI Approved :: MIT License",
                    "Natural Language :: English",
                    "Natural Language :: Spanish",
                    "Operating System :: Unix",
                    "Operating System :: MacOS :: MacOS X",
                    "Programming Language :: C",
                    "Programming Language :: C++",
                    "Programming Language :: Python :: 3.6",
                    "Programming Language :: Python :: Implementation :: CPython",
                    "Topic :: Scientific/Engineering :: Artificial Intelligence"]

NUMPY_MIN_VERSION = "1.15.2"
SCIPY_MIN_VERSION = "1.1.0"
INSTALL_REQUIRES  = ["numpy>={}".format(NUMPY_MIN_VERSION),
                     "scipy>={}".format(SCIPY_MIN_VERSION)]

# Long description is obtained from the "README.md" file
with open("README.md") as f:
    LONG_DESCRIPTION = f.read()

LONG_DESCRIPTION_CONTENT_TYPE = "text/markdown"

# Custom actions when calling to this setup file
CMDCLASS = {"clean": CleanCommand}

# Optional "setuptools" features, requiring
# that this package is imported
SETUPTOOLS_EXTRA_COMMANDS = set(["alias", "bdist_egg", "bdist_wheel",
                                 "develop", "dist_info", "easy_install",
                                 "egg_info", "install_egg_info", "rotate",
                                 "saveopts", "setopt", "test", "upload_docs"])

# Import "setuptools", since at least one of this extra commands have been required
if SETUPTOOLS_EXTRA_COMMANDS.intersection(sys.argv):
    # Import
    import setuptools
    # Optimize
    EXTRA_SETUPTOOLS_ARGS = {
                                "zip_false": False,
                                "include_package_data": True,
                                "extras_require": {
                                                    "all_deps": INSTALL_REQUIRES
                                                  }
                            }
# Otherwise, set the extra arguments as an empty dictionary
EXTRA_SETUPTOOLS_ARGS = {}

# =============================================================================
# Package distribution methods
# =============================================================================

def get_numpy_version():
    """
        Get the version of NumPy.
    """
    # Try to import NumPy and if it is not found,
    # show the error message to the user
    try:
        # Import
        import numpy as np
        # Get the version
        numpy_version = np.__version__
    except:
        # Show the error message
        traceback.print_exc()
        # Set the version as an empty string
        numpy_version = ""

    # Return the obtained version 
    return numpy_version   

def configuration(parent_package = "",
                  top_path       = None):
    """
        Configure "plr" package.
    """
    # Before building the extensions, remove ".MANIFEST".
    # Otherwise it may not be properly updated when the contents of directories change
    if os.path.exists("MANIFEST"):
        os.unlink("MANIFEST")

    # Locally import NumPy
    from numpy.distutils.misc_util import Configuration

    # Create the configuration file
    config = Configuration(None, parent_package, top_path)

    # Avoid non-useful msg
    config.set_options(ignore_setup_xxx_py             = True,
                       assume_default_configuration    = True,
                       delegate_options_to_subpackages = True,
                       quiet                           = True)

    # Add the subpackage where the plr package is
    config.add_subpackage("plr")

    # Return the configuration
    return config

def setup_package():
    """
        Setup "plr" package.
    """
    # Setup the metadata for the package
    metadata = dict(name                          = DISTNAME,
                    description                   = DESCRIPTION,
                    long_description              = LONG_DESCRIPTION,
                    long_description_content_type = LONG_DESCRIPTION_CONTENT_TYPE,
                    maintainer                    = MAINTAINER,
                    maintainer_email              = MAINTAINER_EMAIL,
                    url                           = URL,
                    download_url                  = DOWNLOAD_URL,
                    license                       = LICENSE,
                    version                       = VERSION,
                    classifiers                   = CLASSIFIERS,
                    install_requires              = INSTALL_REQUIRES,
                    cmdclass                      = CMDCLASS,
                    **EXTRA_SETUPTOOLS_ARGS)

    # For some actions like installing from pip,
    # NumPy is not required so that setuptools is employed
    if len(sys.argv) == 1 or \
       (len(sys.argv) >= 2 and ("--help" in sys.argv[1:] or \
                               sys.argv[1] in ("--help-commands",
                                               "egg_info",
                                               "--version",
                                               "clean"))):
        try:
            from setuptools import setup
        except ImportError:
            from distutils.core import setup
    # Otherwise, NumPy is required, and, so, its setup
    # configuration method must be imported
    else:
        # Get the version
        numpy_version = get_numpy_version()
        # If NumPy is not installed, show the corresponding message to the user
        if not numpy_version:
            raise ImportError("NumPy is not installed. At least version '{}' is required.".format(NUMPY_MIN_VERSION))
        # Otherwise, if the version is not the one required,
        # show the got and required version with the corresponding message
        elif parse_version(numpy_version) < parse_version(NUMPY_MIN_VERSION):
            raise ImportError("Your installation of NumPy is not the required, got '{}' but requires '>={}'".format(numpy_version, NUMPY_MIN_VERSION))

        # Import the required "setup" method from NumPy
        from numpy.distutils.core import setup

        # Setup the configuration for the package
        metadata["configuration"] = configuration

    # Setup the package
    setup(**metadata)

# Only called if this file is the main one
if __name__ == "__main__":
    # Setup the package
    setup_package()

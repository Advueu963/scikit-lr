# =============================================================================
# Imports
# =============================================================================

# Standard
from distutils.command.clean import clean as Clean
from pkg_resources import parse_version
from platform import python_version
from os import walk, unlink
from os.path import exists, abspath, join, splitext
import shutil
import sys
import traceback
import os

# Local application
import plr


# =============================================================================
# Constants
# =============================================================================

# Name and version
DISTNAME = "plr"
VERSION = plr.__version__

# Description
DESCRIPTION = "A set of Python modules for Label Ranking problems."
with open("README.md", encoding="utf-8") as f:
    LONG_DESCRIPTION = f.read()
LONG_DESCRIPTION_CONTENT_TYPE = "text/markdown"

# Maintainer
MAINTAINER = "Juan Carlos Alfaro Jiménez"
MAINTAINER_EMAIL = "JuanCarlos.Alfaro@uclm.es"

# URLs
URL = "https://github.com/alfaro96/plr"
DOWNLOAD_URL = "https://pypi.org/project/plr/#files"
PROJECT_URLS = {
    "Bug Tracker": "https://github.com/alfaro96/plr/issues",
    "Soure Code": "https://github.com/alfaro96/plr"
}

# License
LICENSE = "MIT"

# Classifiers
CLASSIFIERS = [
    "Development Status :: 5 - Production/Stable",
    "Intended Audience :: Education",
    "Intended Audience :: Science/Research",
    "License :: OSI Approved :: MIT License",
    "Natural Language :: English",
    "Natural Language :: Spanish",
    "Operating System :: MacOS :: MacOS X",
    "Operating System :: POSIX :: Linux",
    "Operating System :: Unix",
    "Programming Language :: C",
    "Programming Language :: C++",
    "Programming Language :: Cython",
    "Programming Language :: Python :: 3.6",
    "Programming Language :: Python :: 3.7",
    "Programming Language :: Python :: Implementation :: CPython",
    "Topic :: Scientific/Engineering :: Artificial Intelligence"
]

# Required packages
NUMPY_MIN_VERSION = "1.15.2"
SCIPY_MIN_VERSION = "1.1.0"
INSTALL_REQUIRES = [
    "numpy>={}".format(NUMPY_MIN_VERSION),
    "scipy>={}".format(SCIPY_MIN_VERSION),
]


# =============================================================================
# Classes
# =============================================================================

# =============================================================================
# Clean command
# =============================================================================
class CleanCommand(Clean):
    """Custom clean command to remove build artifacts."""

    def run(self):
        """Execute the custom clean command."""
        # Call to the method of the parent
        Clean.run(self)

        # Locate the current working directory
        cwd = abspath(os.path.dirname(__file__))

        # Remove the .c and .cpp files if the current
        # working directory is not a distribution
        remove_c_files = not exists(join(cwd, "PKG-INFO"))

        # Remove the build directory if it exists
        if exists("build"):
            shutil.rmtree("build")

        # Check the directories and files to remove
        for (dirpath, dirnames, filenames) in walk("plr"):
            # Files
            for filename in filenames:
                # Get the current extension of the file
                filename_ext = splitext(filename)[1]
                # If the extension is either .c or .cpp, check
                # whether to remove it (taking into account that
                # it cannot be a distribution)
                if filename_ext in [".c", ".cpp"] and remove_c_files:
                    # Only remove the .c and .cpp files that have
                    # been generated by Cython, that is, if they
                    # exists, in the same directory, a .pyx
                    # file with the same name
                    pyx_filename = str.replace(filename, filename_ext, ".pyx")
                    # If this .pyx file exists, then, remove
                    # the corresponding .c or .cpp one
                    if exists(join(dirpath, pyx_filename)):
                        unlink(join(dirpath, filename))
            # Directories
            for dirname in dirnames:
                # Remove the __pycache__ and .pytest_cache folders
                if dirname in ["__pycache__", ".pytest_cache"]:
                    shutil.rmtree(join(dirpath, dirname))


# Custom actions when calling to this setup file
CMDCLASS = {"clean": CleanCommand}

# Optional setuptools features, requiring that this package is imported
SETUPTOOLS_EXTRA_COMMANDS = {
        "alias", "bdist_egg", "bdist_wheel",
        "develop", "dist_info", "easy_install",
        "egg_info", "install_egg_info", "rotate",
        "saveopts", "setopt", "test", "upload_docs"
}

# Import setuptools if at least one of the extra commands have been required
if SETUPTOOLS_EXTRA_COMMANDS.intersection(sys.argv):
    # Import
    import setuptools
    # Optimize
    EXTRA_SETUPTOOLS_ARGS = {
        "zip_false": False,
        "include_package_data": True,
        "extras_require": {
            "all_deps": INSTALL_REQUIRES
        }
    }

# Otherwise, set the extra arguments as an empty set
EXTRA_SETUPTOOLS_ARGS = {}


# =============================================================================
# Methods
# =============================================================================

def get_numpy_version():
    """Return a string containing the NumPy
    version string (empty string if not installed)."""
    # Try to import NumPy and if it is not found,
    # show the error message to the user
    try:
        # Import
        import numpy as np
        # Get the version
        numpy_version = np.__version__
    except ImportError:
        # Show the error message
        traceback.print_exc()
        # Set the version as an empty string
        numpy_version = ""

    # Return the NumPy version
    return numpy_version


def configuration(parent_package="", top_path=None):
    """Configure the plr package."""
    # Before building the extensions, remove .MANIFEST.
    # Otherwise it may not be properly updated when
    # the contents of directories change
    if exists("MANIFEST"):
        unlink("MANIFEST")

    # Locally import the distribution utils of NumPy
    from numpy.distutils.misc_util import Configuration

    # Create the configuration file
    config = Configuration(None, parent_package, top_path)

    # Avoid useless messages
    config.set_options(
        ignore_setup_xxx_py=True,
        assume_default_configuration=True,
        delegate_options_to_subpackages=True,
        quiet=True)

    # Add the subpackage where the plr package is
    config.add_subpackage("plr")

    # Return the configuration
    return config


def setup_package():
    """Configure the plr package."""
    # Setup the metadata for the package
    metadata = dict(
        name=DISTNAME,
        version=VERSION,
        description=DESCRIPTION,
        long_description=LONG_DESCRIPTION,
        long_description_content_type=LONG_DESCRIPTION_CONTENT_TYPE,
        maintainer=MAINTAINER,
        maintainer_email=MAINTAINER_EMAIL,
        url=URL,
        download_url=DOWNLOAD_URL,
        project_urls=PROJECT_URLS,
        license=LICENSE,
        classifiers=CLASSIFIERS,
        install_requires=INSTALL_REQUIRES,
        cmdclass=CMDCLASS,
        **EXTRA_SETUPTOOLS_ARGS)

    # For some actions like installing from pip, NumPy
    # is not required. So the setuptools are employed
    if (len(sys.argv) == 1 or
            len(sys.argv) >= 2 and ("--help" in sys.argv[1:] or
                                    sys.argv[1] in (
                                        "--help-commands",
                                        "egg_info",
                                        "--version",
                                        "clean"
                                    ))):
        try:
            from setuptools import setup
        except ImportError:
            from distutils.core import setup
    # Otherwise, NumPy is required. So, its setup
    # configuration method must be imported
    else:
        # Check the Python version installed in the system
        if sys.version_info < (3, 6):
            raise RuntimeError("plr requires Python 3.6 or later. "
                               "The current Python version is {} "
                               "installed in {}."
                               .format(python_version(), sys.executable))
        # Get the version
        numpy_version = get_numpy_version()
        # If NumPy is not installed, show the
        # corresponding message to the user
        if not numpy_version:
            raise ImportError("NumPy is not installed. "
                              "At least version {} is required."
                              .format(NUMPY_MIN_VERSION))
        # Otherwise, if the version is not the one required,
        # show the got and required version with the corresponding message
        elif parse_version(numpy_version) < parse_version(NUMPY_MIN_VERSION):
            raise ImportError("Your installation of NumPy is not "
                              "the required. Got {} but requires >={}."
                              .format(numpy_version, NUMPY_MIN_VERSION))
        # Import the required "setup" method from NumPy
        from numpy.distutils.core import setup
        # Setup the configuration for the package
        metadata["configuration"] = configuration

    # Setup the package
    setup(**metadata)


# =============================================================================
# Main
# =============================================================================
if __name__ == "__main__":
    """Only called when this file is the "main" one."""
    # Setup the package
    setup_package()
